// src/graphql/services/reservation.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { ReservationEntity } from '../../entities/reservation.entity';
import { NotificationEntity } from '../../entities/notification.entity';
import { from, map, Observable, switchMap, catchError, throwError, forkJoin } from 'rxjs';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { StatusEnum } from '../../entities/status.enum';
import { NotificationClient } from 'src/grpc-service/notification/notification.client';
import { CreateReservationInput } from '../resolvers/dto/create-reservation.input';
import { UpdateReservationInput } from '../resolvers/dto/update-reservation.input';

@Injectable()
export class ReservationService {
  constructor(
    @InjectRepository(ReservationEntity)
    private readonly reservationRepository: Repository<ReservationEntity>,
    @InjectRepository(NotificationEntity)
    private readonly notificationRepository: Repository<NotificationEntity>,
    private readonly notificationClient: NotificationClient,
  ) { }

  listReservations(
    skip: number,
    limit: number,
  ): Observable<ReservationEntity[]> {
    return from(
      this.reservationRepository.find({
        relations: ['user', 'room'],
        skip: skip || 0,
        take: limit || 10,
        order: { createdAt: 'DESC' },
      }),
    );
  }

  reservation(id: string): Observable<ReservationEntity> {
    return from(this.reservationRepository.findOne({
      where: { id },
      relations: ['user', 'room']
    })).pipe(
      map((reservation: ReservationEntity | null) => {
        if (!reservation) {
          throw new NotFoundException(`Reservation with ID ${id} not found`);
        }
        return reservation;
      }),
      catchError((error) => {
        console.error('‚ùå Erreur lors de la r√©cup√©ration de r√©servation:', error);
        return throwError(() => error);
      })
    );
  }

  createReservation(
    reservationDto: CreateReservationInput,
  ): Observable<ReservationEntity> {
    console.log('üìù GraphQL: Cr√©ation r√©servation avec:', reservationDto);

    // CORRECTION: Validation des donn√©es d'entr√©e
    if (!reservationDto.userId || !reservationDto.roomId) {
      throw new Error('userId et roomId sont requis');
    }
    if (!reservationDto.startTime || !reservationDto.endTime) {
      throw new Error('startTime et endTime sont requis');
    }

    // Convertir les strings en dates et cr√©er la r√©servation
    const reservation = {
      userId: reservationDto.userId,
      roomId: reservationDto.roomId,
      startTime: new Date(reservationDto.startTime),
      endTime: new Date(reservationDto.endTime),
      location: 'GraphQL Created Location',
      status: StatusEnum.PENDING,
    };

    console.log('üíæ GraphQL: R√©servation √† sauvegarder:', reservation);

    return from(
      this.reservationRepository.save(
        this.reservationRepository.create(reservation),
      ),
    ).pipe(
      switchMap((savedReservation) => {
        console.log('‚úÖ GraphQL: R√©servation sauvegard√©e:', savedReservation);

        // CORRECTION: Cr√©er la notification en base ET via gRPC
        const notificationEntity = this.notificationRepository.create({
          reservationId: parseInt(savedReservation.id),
          message: `Nouvelle r√©servation GraphQL cr√©√©e pour la chambre ${savedReservation.roomId}`,
          notificationDate: new Date(),
          isSent: false,
        });

        const saveNotification$ = from(this.notificationRepository.save(notificationEntity));

        // Cr√©er une notification via gRPC en parall√®le
        const notificationRequest = {
          reservationId: parseInt(savedReservation.id),
          message: `Nouvelle r√©servation GraphQL cr√©√©e pour la chambre ${savedReservation.roomId}`,
          notificationDate: new Date().toISOString(),
          isSent: false,
        };

        // Appel gRPC asynchrone (ne pas bloquer si le service est indisponible)
        try {
          this.notificationClient.createNotification(notificationRequest).subscribe({
            next: (result) => {
              console.log('‚úÖ Notification gRPC cr√©√©e:', result);
            },
            error: (error) => {
              console.error('‚ùå Erreur lors de la cr√©ation de la notification gRPC:', error);
            }
          });
        } catch (error) {
          console.error('‚ùå Service gRPC indisponible:', error);
        }

        // Recharger avec les relations ET sauvegarder la notification
        const reloadReservation$ = from(this.reservationRepository.findOne({
          where: { id: savedReservation.id },
          relations: ['user', 'room']
        }));

        return forkJoin([reloadReservation$, saveNotification$]).pipe(
          map(([reservationWithRelations, notification]) => {
            console.log('üìã GraphQL: R√©servation avec relations:', reservationWithRelations);
            console.log('üìß Notification sauvegard√©e:', notification);
            if (!reservationWithRelations) {
              throw new Error('Impossible de recharger la r√©servation avec ses relations');
            }
            return reservationWithRelations;
          })
        );
      }),
      catchError((error) => {
        console.error('‚ùå GraphQL: Erreur lors de la cr√©ation de r√©servation:', error);
        return throwError(() => error);
      })
    );
  }

  updateReservation(
    id: string,
    input: Partial<UpdateReservationInput>,
  ): Observable<ReservationEntity> {
    console.log(`üìù GraphQL: Mise √† jour r√©servation ${id} avec:`, input);

    return this.reservation(id).pipe(
      switchMap((existingReservation) => {
        console.log('üìã GraphQL: R√©servation existante:', existingReservation);

        // Convertir les strings en dates si n√©cessaire et pr√©parer les donn√©es de mise √† jour
        const updateData: any = { ...existingReservation };

        if (input.userId !== undefined) updateData.userId = input.userId;
        if (input.roomId !== undefined) updateData.roomId = input.roomId;
        if (input.startTime !== undefined) {
          updateData.startTime = new Date(input.startTime);
        }
        if (input.endTime !== undefined) {
          updateData.endTime = new Date(input.endTime);
        }

        console.log('üíæ GraphQL: Donn√©es de mise √† jour:', updateData);

        return from(this.reservationRepository.save(updateData));
      }),
      switchMap((updatedReservation) => {
        console.log('‚úÖ GraphQL: R√©servation mise √† jour:', updatedReservation);

        // Cr√©er une notification de mise √† jour en base
        const notificationEntity = this.notificationRepository.create({
          reservationId: parseInt(id),
          message: `R√©servation GraphQL ${id} mise √† jour`,
          notificationDate: new Date(),
          isSent: false,
        });

        const saveNotification$ = from(this.notificationRepository.save(notificationEntity));

        // Appel gRPC asynchrone
        try {
          const notificationRequest = {
            reservationId: parseInt(id),
            message: `R√©servation GraphQL ${id} mise √† jour`,
            notificationDate: new Date().toISOString(),
            isSent: false,
          };

          this.notificationClient.createNotification(notificationRequest).subscribe({
            next: (result) => {
              console.log('‚úÖ Notification de mise √† jour gRPC cr√©√©e:', result);
            },
            error: (error) => {
              console.error('‚ùå Erreur lors de la cr√©ation de la notification de mise √† jour gRPC:', error);
            }
          });
        } catch (error) {
          console.error('‚ùå Service gRPC indisponible:', error);
        }

        // Recharger avec les relations
        const reloadReservation$ = from(this.reservationRepository.findOne({
          where: { id: updatedReservation.id },
          relations: ['user', 'room']
        }));

        return forkJoin([reloadReservation$, saveNotification$]).pipe(
          map(([reservationWithRelations, notification]) => {
            console.log('üìã GraphQL: R√©servation mise √† jour avec relations:', reservationWithRelations);
            console.log('üìß Notification de mise √† jour sauvegard√©e:', notification);
            if (!reservationWithRelations) {
              throw new Error('Impossible de recharger la r√©servation mise √† jour avec ses relations');
            }
            return reservationWithRelations;
          })
        );
      }),
      catchError((error) => {
        console.error('‚ùå GraphQL: Erreur lors de la mise √† jour de r√©servation:', error);
        return throwError(() => error);
      })
    );
  }

  deleteReservation(id: string): Observable<boolean> {
    console.log(`üóëÔ∏è GraphQL: Suppression r√©servation ${id}`);

    return from(this.reservationRepository.findOne({ where: { id } })).pipe(
      switchMap((reservation) => {
        if (!reservation) {
          console.log(`‚ùå GraphQL: R√©servation ${id} non trouv√©e`);
          return throwError(() => new NotFoundException(`Reservation with ID ${id} not found`));
        }

        console.log('üóëÔ∏è Suppression des notifications li√©es √† la r√©servation:', id);

        // Supprimer toutes les notifications li√©es √† cette r√©servation
        return from(
          this.notificationRepository.delete({ reservationId: parseInt(id) })
        ).pipe(
          switchMap(() => {
            console.log('üóëÔ∏è Suppression de la r√©servation:', id);
            // Puis supprimer la r√©servation
            return from(this.reservationRepository.delete(id));
          }),
          map((result) => {
            const success = result.affected ? result.affected > 0 : false;
            console.log(success ? '‚úÖ R√©servation supprim√©e avec succ√®s' : '‚ùå √âchec suppression r√©servation');
            return success;
          }),
          catchError((error) => {
            console.error('‚ùå Erreur lors de la suppression:', error);
            return throwError(() => error);
          })
        );
      })
    );
  }
}